<?php
/* ====================
[BEGIN_COT_EXT]
Hooks=global
[END_COT_EXT]
==================== */

defined('COT_CODE') or die('Wrong URL');

require_once 'vendor/autoload.php';
require_once cot_incfile('cache');

interface CompilerInterface {
    public function getParsedFiles();
    public function addImportPath($path);
    public function setFormatter($name);
}

class lessCompiler extends lessc implements CompilerInterface
{
    public function getParsedFiles()
    {
        return parent::allParsedFiles();
    }

    public function addImportPath($path)
    {
        parent::addImportDir($path);
    }
}

class scssCompiler extends \Leafo\ScssPhp\Compiler implements CompilerInterface
{
    public function getParsedFiles()
    {
        return parent::getParsedFiles();
    }

    public function addImportPath($path)
    {
        parent::addImportPath($path); // TODO: Change the autogenerated stub
    }

    public function setFormatter($formatterClassName){

        switch($formatterClassName){
            case 'compressed':
                $formatterClassName = 'Leafo\ScssPhp\Formatter\Compressed';
                break;

            default:
                $formatterClassName = '';
        }

        parent::setFormatter($formatterClassName);
    }
}

class vLess extends Resources
{

    protected $_cache;
    protected $_debug;
    protected $_force;
    protected $_files;
    protected $_allowedExtensions;

    public static function instance()
    {
        return new self;
    }

    public function __construct()
    {
        global $cache, $cfg;

        $this->_allowedExtensions = array(
            'less' => true,
            'scss' => true
        );

        $this->_files = array_intersect_key(
            static::$registry, $this->_allowedExtensions
        );

        if (!$this->_files)
            return $this;

        $this->_debug = $cfg['debug_mode'];
        $this->_force = ($this->_debug) ? cot_import('vlessforce', 'G', 'BOL') : false;


        if ($cache) {
            $this->_cache = $cache;
        } else {
            $this->_cache = new Cache();
            $this->_cache->disk = new File_cache($cfg['cache_dir']);
        }

        return $this;
    }

    public function run()
    {

        if (!$this->_files)
            return;


        foreach ($this->_files as $filesExtension => $files) {
            foreach ($files['files'] as $filesScopeName => $filesScopeRow) {
                foreach ($filesScopeRow as $filesOrder => $filesOrderRow) {
                    foreach ($filesOrderRow as $file) {
                        $fileInfo = pathinfo($file);

                        $outFile = "{$fileInfo['dirname']}/{$fileInfo['filename']}.css";

                        $in = $file;
                        if ($this->_cache && $this->_cache->disk->exists($fileInfo['filename'], 'vless') && file_exists($outFile)) {
                            $in = $this->_cache->disk->get($fileInfo['filename'], 'vless');
                        }

                        $data = $this->execute($in, $filesExtension);

                        if (is_string($in) || ($in['updated'] !== $data['updated'])) {
                            $this->_cache->disk->store($fileInfo['filename'], $data, 'vless');
                            file_put_contents($outFile, $data['compiled']);
                        }

                        self::addFile($outFile, 'css', $filesOrder, $filesScopeName);
                    }
                }
            }

            unset(static::$registry[$filesExtension]);
        }
    }

    public function execute($in)
    {
        // assume no root
        $root = null;

        if (is_string($in)) {
            $root = $in;
        } elseif (is_array($in) and isset($in['root'])) {
            if ($this->_force or !isset($in['files'])) {
                // If we are forcing a recompile or if for some reason the
                // structure does not contain any file information we should
                // specify the root to trigger a rebuild.
                $root = $in['root'];
            } elseif (isset($in['files']) and is_array($in['files'])) {
                foreach ($in['files'] as $fname => $ftime) {
                    if (!file_exists($fname) or filemtime($fname) > $ftime) {
                        // One of the files we knew about previously has changed
                        // so we should look at our incoming root again.
                        $root = $in['root'];
                        break;
                    }
                }
            }
        } else {
            // TODO: Throw an exception? We got neither a string nor something
            // that looks like a compatible lessphp cache structure.
            $data = null;
        }

        if ($root !== null) {
            // If we have a root value which means we should rebuild.


            $compilerClass = pathinfo($root, PATHINFO_EXTENSION) . 'Compiler';

            if (!class_exists($compilerClass))
                throw new Exception('Compiler class not exists.');

            $compiler = new $compilerClass();
            $compiler->addImportPath(pathinfo($root, PATHINFO_DIRNAME));

            if (!$this->_debug)
                $compiler->setFormatter('compressed');

            $data = array(
                'root' => $root,
                'compiled' => $compiler->compile(file_get_contents($root)),
                'files' => $compiler->getParsedFiles(),
                'updated' => time()
            );
        } else {
            // No changes, pass back the structure
            // we were given initially.
            $data = $in;
        }

        return $data;
    }

}

vLess::instance()
    ->run();